/* -*- sv -*- File generated by the BNF Converter (bnfc 2.9.6). */

/*******************************************************/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

`include "C/CInterp.svh"


task Interp::visitProgram(Program p); endtask //abstract class
task Interp::visitStmt_Item(Stmt_Item p); endtask //abstract class
task Interp::visitVar_Assignment(Var_Assignment p); endtask //abstract class
task Interp::visitJump_Stmt(Jump_Stmt p); endtask //abstract class
task Interp::visitFuncOrProcCall(FuncOrProcCall p); endtask //abstract class
task Interp::visitBuiltin_Task(Builtin_Task p); endtask //abstract class
task Interp::visitBuiltin_Fn(Builtin_Fn p); endtask //abstract class
task Interp::visitPrint_Arg(Print_Arg p); endtask //abstract class
task Interp::visitProc_Definition(Proc_Definition p); endtask //abstract class
task Interp::visitFunc_Definition(Func_Definition p); endtask //abstract class
task Interp::visitDefinition(Definition p); endtask //abstract class
task Interp::visitFormal_Arg(Formal_Arg p); endtask //abstract class
task Interp::visitElse_If(Else_If p); endtask //abstract class
task Interp::visitElse_Opt(Else_Opt p); endtask //abstract class
task Interp::visitConditional_Stmt(Conditional_Stmt p); endtask //abstract class
task Interp::visitLoop_Stmt(Loop_Stmt p); endtask //abstract class
task Interp::visitFor_Init_Opt(For_Init_Opt p); endtask //abstract class
task Interp::visitExpr_Opt(Expr_Opt p); endtask //abstract class
task Interp::visitFor_Step_Opt(For_Step_Opt p); endtask //abstract class
task Interp::visitOp(Op p); endtask //abstract class
task Interp::visitExpr(Expr p); endtask //abstract class
task Interp::visitPrimary(Primary p); endtask //abstract class
task Interp::visitRange_Expr_Opt(Range_Expr_Opt p); endtask //abstract class
task Interp::visitRange_Expr(Range_Expr p); endtask //abstract class
task Interp::visitUnary_Operator(Unary_Operator p); endtask //abstract class
task Interp::visitInc_Or_Dec_Operator(Inc_Or_Dec_Operator p); endtask //abstract class
task Interp::visitNumber(Number p); endtask //abstract class
task Interp::visitString_Literal(String_Literal p); endtask //abstract class

task Interp::visitProgram1(Program1 p);
  exit_fatal = 0;

  p.liststmt_item_.accept(this);
endtask

task Interp::visitVarDeclStmt(VarDeclStmt p);
  Symbol s = lookup(p.ident_, CURRENT);
  if(s == null)
    s = install(p.ident_, UNDEF);
  else
    $write("\nWARNING: variable %s already declared: re-declared at line %0d!!\n", s.name[0], p.line_number);

  //visitIdent(p.ident_);
endtask

task Interp::visitVarAssDeclStmt(VarAssDeclStmt p);
  var_install = 1;
  p.var_assignment_.accept(this);
endtask

task Interp::visitAssignmentStmt(AssignmentStmt p);
  p.var_assignment_.accept(this);
endtask

task Interp::visitConditionalStmt(ConditionalStmt p);
  p.conditional_stmt_.accept(this);
endtask

task Interp::visitIncDecOpStmt(IncDecOpStmt p);
  visitIdent(p.ident_);
  p.inc_or_dec_operator_.accept(this);
endtask

task Interp::visitLoopStmt(LoopStmt p);
  in_loop++;
  p.loop_stmt_.accept(this);
  in_loop--;
endtask

task Interp::visitJumpStmt(JumpStmt p);
  p.jump_stmt_.accept(this);
endtask

task Interp::visitBlockStmt(BlockStmt p);
  p.liststmt_item_.accept(this);
endtask

task Interp::visitBuiltInStmt(BuiltInStmt p);
  p.builtin_task_.accept(this);
endtask

task Interp::visitProcDefStmt(ProcDefStmt p);
  p.proc_definition_.accept(this);
endtask

task Interp::visitFuncDefStmt(FuncDefStmt p);
  p.func_definition_.accept(this);
endtask

task Interp::visitProcCallStmt(ProcCallStmt p);
  call_type = PROC;

  p.funcorproccall_.accept(this);
endtask

task Interp::visitAssignment(Assignment p);

  Symbol s;
  NumVal num;
  Datum d1, d2;
  Datum r1, r2;

  p.expr_.accept(this);
  d1 = pop();

  if ( var_install ) begin
    Symbol s_;

    s_ = lookup(p.ident_, CURRENT);
    if (s_)
      $write("\nWARNING: variable %s already declared: re-declared at line %0d!!\n", s_.name, p.line_number);
    else
      s_ = install(p.ident_, UNDEF);
    var_install = 0;
  end
  visitIdent(p.ident_);
  p.range_expr_opt_.accept(this);

  r2 = pop();
  r1 = pop();
  d2 = pop();

  s = d2.sym;

  if ( s.type_ == UNDEF ) begin
    num = new();
    s.u = num;
  end else begin
    $cast(num, s.u);
  end

  if ( r2.ival > 63 || r2.ival < 0 ) begin
    $fatal("\nERROR: bad bit select range value for variable %s: %0d at line %0d!!\n", s.name, uint'(r2.ival), p.line_number);
  end

  if ( r1.ival > 63 || r1.ival < 0 ) begin
    $fatal("\nERROR: bad bit select range value for variable %s: %0d at line %0d!!\n", s.name, uint'(r1.ival), p.line_number);
  end

  if ( r2.ival > r1.ival ) begin
    $fatal("\nERROR: bad bit select range values for variable %s: %0d:%0d at line %0d!!\n", s.name, uint'(r1.ival), uint'(r2.ival), p.line_number);
  end

  if ( longint'(r1.ival - r2.ival + 1) < 64 ) begin
    ulongint mask = (ulongint'(1) << ulongint'(r1.ival - r2.ival + 1)) - 1;

    if ( d1.ival > mask )
      $write("\nWARNING: RHS(%0d) larger than LHS range max (%0d) in assignment to variable %s at line %0d!!\n", ulongint'(d1.ival), ulongint'(mask), s.name, p.line_number);

    d1.ival = real'(ulongint'(d1.ival) & ulongint'(mask));

    mask = ~(mask << ulongint'(r2.ival));
    num.val = ulongint'(num.val) & mask;

    num.val = real'(ulongint'(num.val) | (ulongint'(d1.ival) << ulongint'(r2.ival)));
  end else
    num.val = d1.ival;

  s.type_ = VAR;
endtask

task Interp::visitBreak(Break p);
  break_jump = 1;
endtask

task Interp::visitContinue(Continue p);
  continue_jump = 1;
endtask

task Interp::visitReturn(Return p);
  p.expr_opt_.accept(this);

`ifdef DEBUG
  $write("returning\n");
`endif
  return_jump = 1;
endtask

task Interp::visitCall(Call p);
  Datum d1, d2;
  Symbol s;
  ProcDefn def;
  real args[$];
  Type_ call_type_ = call_type;

  visitIdent(p.ident_);

  d1 = pop();
  s = d1.sym;
  if ( s.type_ == UNDEF || !(s.type_ == FUNC || s.type_ == PROC) )
    $fatal("\nERROR: procedure or function \"%s\" not defined but called at line %0d!!\n", d1.sym.name, p.line_number);
  $cast(def, s.u);

  if ( p.listexpr_.v.size() != def.formals.size() )
    $fatal("\nERROR: Number of args for procedure or function \"%s\" must match number of parameters in definition. At line %0d!!\n", d1.sym.name, p.line_number);

  p.listexpr_.accept(this);
  for (uint i = 0; i < def.formals.size(); i++) begin
    Datum d;
    d = pop();
    args.push_back(d.ival);
  end

  in_call++;
  inc_scope();
  for ( uint i = 0; i < def.formals.size(); i++ ) begin
    Symbol s1;
    NumVal num = new();

    s1 = install(def.formals[i], UNDEF);
    s1.type_ = VAR;

    num.val = args[i];

    s1.u = num;
`ifdef DEBUG
    begin
      string dbg_str = s1.do_print();
      $write("Symbol: %s\n", dbg_str);
    end
`endif
  end
  def.code.accept(this);
  if ( return_jump ) begin
    return_jump = 0;
  end else if ( call_type_ == FUNC ) begin
    $fatal("\nERROR: function \"%s\" must return a value. At line %0d!!\n", d1.sym.name, p.line_number);
  end
`ifdef DEBUG
  $write("returned. scope = %0d in_call = %0d\n", scope, in_call);
`endif
  if ( call_type_ == FUNC )
    d2 = pop();
  dec_scope();
  in_call--;
  if ( call_type_ == FUNC )
    push(d2);
endtask

task Interp::visitPrint(Print p);
  p.listprint_arg_.accept(this);
endtask

task Interp::visitRegWr(RegWr p);
  Datum d1, d2, d3;

  p.expr_1.accept(this);
  p.expr_2.accept(this);

  d3 = pop();
  d2 = pop();

  $write("writing csr: %0d %0d, at line %0d\n", ulongint'(d2.ival), ulongint'(d3.ival), p.line_number);
endtask

task Interp::visitWait(Wait p);
  Datum d;

  p.expr_.accept(this);

  d = pop();
  #d;
endtask

task Interp::visitFatal(Fatal p);
  Datum d;

  p.expr_.accept(this);

  d = pop();

  $fatal("FATAL: %d at line %0d!!!!\n", uint'(d.ival), p.line_number);
  exit_fatal = uint'(d.ival);
endtask

task Interp::visitRegRd(RegRd p);
  Datum d2;
  uint data = 0;

  p.expr_.accept(this);

  d2 = pop();

  //data = read_csr( (unsigned long) d2.ival );
  data = 0;
  d2.ival = data;
  push(d2);
endtask

task Interp::visitCeil(Ceil p);
  Datum d;

  p.expr_.accept(this);
  d = pop();

  d.ival = $ceil(d.ival);
  push(d);
endtask

task Interp::visitFloor(Floor p);
  Datum d;

  p.expr_.accept(this);
  d = pop();

  d.ival = $floor(d.ival);
  push(d);
endtask

task Interp::visitLog2(Log2 p);
  Datum d;

  p.expr_.accept(this);
  d = pop();

  d.ival = $clog2(uint'(d.ival));

  push(d);
endtask

task Interp::visitSys(Sys p);
  Datum d;
  string u;

  p.string_literal_.accept(this);
  d = pop();

  u = d.sval;

  $write("sys %s\n", u);

  d.ival = $system(u);
  push(d);
endtask

task Interp::visitIsDefd(IsDefd p);
  Datum d;
  Symbol s = lookup(p.ident_);

  if ( s == null )
    d.ival = 0;
  else
    d.ival = 1;

  push(d);
endtask

task Interp::visitPrExpr(PrExpr p);
  Datum d;
  string str;

  p.expr_.accept(this);

  d = pop();

  str.itoa(d.ival);
  prstr = {prstr, str};
endtask

task Interp::visitPrString(PrString p);
  Datum d;
  string str;

  p.string_literal_.accept(this);
  d = pop();

  str = str_replace(d.sval.substr(1, d.sval.len() - 2), "\\n", "\n");
  str = str_replace(str, "\\t", "\t");
  prstr = {prstr, str};
endtask

task Interp::visitPrHex(PrHex p);
  Datum d;
  string str;

  p.expr_.accept(this);

  d = pop();

  str.hextoa(d.ival);
  prstr = {prstr, str};
endtask

task Interp::visitPrBin(PrBin p);
  Datum d;
  string str;

  p.expr_.accept(this);

  d = pop();

  str.bintoa(d.ival);
  prstr = {prstr, str};
endtask

task Interp::visitProcDef(ProcDef p);
  defn_type = PROC;
  p.definition_.accept(this);
endtask

task Interp::visitFuncDef(FuncDef p);
  defn_type = FUNC;
  p.definition_.accept(this);
endtask

task Interp::visitDefn(Defn p);
  Datum d1, d2;
  Symbol s;
  ProcDefn def = new();

  visitIdent(p.ident_);
  d1 = pop();
  s = d1.sym;
  if ( s.type_ != UNDEF )
    $fatal("\nERROR: using a pre-defined variable \"%s\" for function or procedure name at line %0d!!\n", d1.sym.name, p.line_number);
  s.type_ = defn_type;

  p.listformal_arg_.accept(this);

  for (uint i = 0; i < p.listformal_arg_.v.size(); i++) begin
    Datum f1;

    f1 = pop();
    def.formals.push_back(f1.sval);
  end
  /*
   * p.stmt_item_.accept(this);
   */
  def.code = p.stmt_item_;

  s.u = def;
endtask

task Interp::visitFormal(Formal p);
  Datum d;

  d.sval = p.ident_;
  push(d);

  //visitIdent(p.ident_);
endtask

task Interp::visitElsIf(ElsIf p);
  Datum d;

  pop();
  p.expr_.accept(this);

  d = top();
  if ( d.ival )
    p.stmt_item_.accept(this);
endtask

task Interp::visitElseIsEmpty(ElseIsEmpty p);
endtask

task Interp::visitElseIsElse(ElseIsElse p);
  p.stmt_item_.accept(this);
endtask

task Interp::visitIf(If p);
  Datum d;

  p.expr_.accept(this);

  d = top();
  if ( d.ival )
    p.stmt_item_.accept(this);
  else
    p.listelse_if_.accept(this);

  d = top();
  if (! d.ival )
    p.else_opt_.accept(this);

`ifdef DEBUG
  $write("popping if \n");
`endif
  //pop();

endtask

task Interp::visitWhile(While p);
  Datum d;

  p.expr_.accept(this);
  d = pop();

  while ( d.ival != 0 ) begin
    p.stmt_item_.accept(this);

    if ( break_jump || return_jump ) begin
      break_jump = 0;
      break;
    end

    if ( continue_jump )
      continue_jump = 0;

    p.expr_.accept(this);
    d = pop();
  end
endtask

task Interp::visitFor(For p);
  Datum d;

  p.for_init_opt_.accept(this);
  p.expr_opt_.accept(this);
  d = pop();

  while( d.ival ) begin
    p.stmt_item_.accept(this);

    if( break_jump || return_jump ) begin
      break_jump = 0;
      break;
    end

    if( continue_jump )
      continue_jump = 0;

    p.for_step_opt_.accept(this);

    p.expr_opt_.accept(this);
    d = pop();
  end
endtask

task Interp::visitForInitIsEmpty(ForInitIsEmpty p);
endtask

task Interp::visitForInitIsInit(ForInitIsInit p);
  p.var_assignment_.accept(this);
endtask

task Interp::visitForInitIsVarInit(ForInitIsVarInit p);
  var_install = 1;
  p.var_assignment_.accept(this);
endtask

task Interp::visitExprIsEmpty(ExprIsEmpty p);
  Datum d;
  d.ival = 1;
  push(d);
endtask

task Interp::visitExprIsExpr(ExprIsExpr p);
  p.expr_.accept(this);
endtask

task Interp::visitForStepIsEmpty(ForStepIsEmpty p);
endtask

task Interp::visitForStepIsAssignment(ForStepIsAssignment p);
  p.var_assignment_.accept(this);
endtask

task Interp::visitForStepIsIncOrDec(ForStepIsIncOrDec p);
  visitIdent(p.ident_);
  p.inc_or_dec_operator_.accept(this);
endtask

task Interp::visitPow(Pow p);
  binary_op = POW;
endtask

task Interp::visitMul(Mul p);
  binary_op = MUL;
endtask

task Interp::visitDiv(Div p);
  binary_op = DIV;
endtask

task Interp::visitMod(Mod p);
  binary_op = MOD;
endtask

task Interp::visitAdd(Add p);
  binary_op = ADD;
endtask

task Interp::visitSub(Sub p);
  binary_op = SUB;
endtask

task Interp::visitLAnd(LAnd p);
  binary_op = LAND;
endtask

task Interp::visitXor(Xor p);
  binary_op = XOR;
endtask

task Interp::visitLOr(LOr p);
  binary_op = LOR;
endtask

task Interp::visitRsh(Rsh p);
  binary_op = RSH;
endtask

task Interp::visitLsh(Lsh p);
  binary_op = LSH;
endtask

task Interp::visitLt(Lt p);
  binary_op = LT;
endtask

task Interp::visitLeq(Leq p);
  binary_op = LEQ;
endtask

task Interp::visitGt(Gt p);
  binary_op = GT;
endtask

task Interp::visitGeq(Geq p);
  binary_op = GEQ;
endtask

task Interp::visitEq(Eq p);
  binary_op = EQ;
endtask

task Interp::visitNeq(Neq p);
  binary_op = NEQ;
endtask

task Interp::visitAnd(And p);
  binary_op = AND;
endtask

task Interp::visitOr(Or p);
  binary_op = OR;
endtask

task Interp::visitExprPrim(ExprPrim p);
  p.primary_.accept(this);
endtask

task Interp::visitExprUnary(ExprUnary p);
  Datum d;
  UnaryOp op;

  p.unary_operator_.accept(this);
  op = unary_op;
  p.expr_.accept(this);

  d = pop();
  case(op)
    MINUS: d.ival = -1 * d.ival;
    NOT:   d.ival = (! d.ival);
    COMP:  d.ival = real'( ((ulongint'(~(uint'(ulongint'(d.ival) >> 32))) << 32) & (~0 >> 1)) | ((~uint'(d.ival))) );
  endcase
  push(d);

endtask

task Interp::visitExprBltin(ExprBltin p);
  p.builtin_fn_.accept(this);
endtask

task Interp::visitExprFuncCall(ExprFuncCall p);
  call_type = FUNC;
  p.funcorproccall_.accept(this);
endtask

task Interp::visitExprTernary(ExprTernary p);
  Datum d1, d2, d3;
  Datum d;

  p.expr_1.accept(this);
  d1 = pop();

  if( d1.ival ) begin
    p.expr_2.accept(this);
    d2 = pop();

    push(d2);
  end else begin
    p.expr_3.accept(this);
    d3 = pop();

    push(d3);
  end
endtask

task Interp::visitEOp(EOp p);

  Datum d1, d2, d3;
  BinaryOp op;

  p.expr_1.accept(this);
  p.op_.accept(this);
  op = binary_op;
  p.expr_2.accept(this);

  d2 = pop();
  d1 = pop();

  case(op)
    POW: d3.ival = real'($pow(real'(d1.ival), real'(d2.ival)));
    MUL: d3.ival = d1.ival * d2.ival;
    DIV: begin
           if ( d2.ival == 0.0 ) begin
             $fatal("\nERROR: division by zero at line %0d!!\n", p.line_number);
           end
           d3.ival = d1.ival / d2.ival;
         end
    MOD: begin
           if ( longint'(d2.ival) == 0 ) begin
             $fatal("\nERROR: mod by zero at line %0d!!\n", p.line_number);
           end
           d3.ival = real'(longint'(d1.ival) % longint'(d2.ival));
         end
    ADD: d3.ival = d1.ival + d2.ival;
    SUB: d3.ival = d1.ival - d2.ival;
    LAND:d3.ival = real'(ulongint'(d1.ival) &  ulongint'(d2.ival));
    XOR: d3.ival = real'(ulongint'(d1.ival) ^  ulongint'(d2.ival));
    LOR: d3.ival = real'(ulongint'(d1.ival) |  ulongint'(d2.ival));
    RSH: d3.ival = real'(ulongint'(d1.ival) >> uint'(d2.ival));
    LSH: d3.ival = real'(ulongint'(d1.ival) << ulongint'(d2.ival));
    LT:  d3.ival = real'(d1.ival <  d2.ival);
    LEQ: d3.ival = real'(d1.ival <= d2.ival);
    GT:  d3.ival = real'(d1.ival >  d2.ival);
    GEQ: d3.ival = real'(d1.ival >= d2.ival);
    EQ:  d3.ival = real'(d1.ival == d2.ival);
    NEQ: d3.ival = real'(d1.ival != d2.ival);
    AND: d3.ival = real'(d1.ival && d2.ival);
    OR:  d3.ival = real'(d1.ival || d2.ival);
    default:    $fatal("\nERROR: Unhandled op at line %0d!!\n", p.line_number);
  endcase

`ifdef DEBUG
  $write("evaluated expression %0d, at line %0d\n", uint'(op), p.line_number);
`endif
  push(d3);
endtask

task Interp::visitPrimIdent(PrimIdent p);

  Datum d, d1, r1, r2;
  ulongint mask = -1;
  NumVal num;

  visitIdent(p.ident_);

  d = pop();
  if ( d.sym.type_ != VAR && d.sym.type_ != UNDEF ) begin
    $fatal("\nERROR: attempt to evaluate a non variable at line 0d!!\n", p.line_number);
  end
  if ( d.sym.type_ == UNDEF ) begin
    $fatal("\nERROR: undefined variable \"%s\" at line 0d!!\n", d.sym.name, p.line_number);
  end

  p.range_expr_opt_.accept(this);

  r2 = pop();
  if ( r2.ival > 63 || r2.ival < 0 ) begin
    $fatal("\nERROR: bad range value: %0d at line %0d!!\n", uint'(r2.ival), p.line_number);
  end

  r1 = pop();
  if ( r1.ival > 63 || r1.ival < 0 ) begin
    $fatal("\nERROR: bad range values: %0d at line %0d!!\n", uint'(r1.ival), p.line_number);
  end

  if ( r2.ival > r1.ival ) begin
    $fatal("\nERROR: bad range values: %0d:%0d at line %0d!!\n", uint'(r1.ival), uint'(r2.ival), p.line_number);
  end

  $cast(num, d.sym.u);

  if ( ulongint'(r1.ival - r2.ival + 1) < 64 ) begin
    mask = (1 << ulongint'(r1.ival - r2.ival + 1)) - 1;
    d1.ival = real'((ulongint'(num.val) >> ulongint'(r2.ival)) & mask);
  end else
    d1.ival = real'(num.val);

  push(d1);
endtask

task Interp::visitPrimNumber(PrimNumber p);
  p.number_.accept(this);
endtask

task Interp::visitRangeExprIsEmpty(RangeExprIsEmpty p);
  Datum d1, d2;
  d1.ival = 0;
  d2.ival = 63;

  push(d2);
  push(d1);
endtask

task Interp::visitRangeExprIsRange(RangeExprIsRange p);
  p.range_expr_.accept(this);
endtask

task Interp::visitRangeExprBit(RangeExprBit p);
  Datum d1, d2;

  p.expr_.accept(this);
  d1 = pop();

  d2.ival = d1.ival;

  push(d2);
  push(d1);
endtask

task Interp::visitRangeExprRange(RangeExprRange p);

  p.expr_1.accept(this);
  p.expr_2.accept(this);
endtask

task Interp::visitUnaryPlus(UnaryPlus p);
  unary_op = PLUS;
endtask

task Interp::visitUnaryMinus(UnaryMinus p);
  unary_op = MINUS;
endtask

task Interp::visitUnaryNot(UnaryNot p);
  unary_op = NOT;
endtask

task Interp::visitUnaryComp(UnaryComp p);
  unary_op = COMP;
endtask

task Interp::visitIncr(Incr p);
  Symbol s;
  Datum d;
  NumVal num;

  d = pop();
  s = d.sym;
  $cast(num, s.u);
  num.val++;
endtask

task Interp::visitDecr(Decr p);
  Symbol s;
  Datum d;
  NumVal num;

  d = pop();
  s = d.sym;
  $cast(num, s.u);
  num.val--;
endtask

task Interp::visitDecimal(Decimal p);
  visitDecimal_Number(p.decimal_number_);
endtask

task Interp::visitBinary(Binary p);
  visitBinaryNumber(p.binarynumber_);
endtask

task Interp::visitHex(Hex p);
  visitHexNumber(p.hexnumber_);
endtask

task Interp::visitReal(Real p);
  visitReal_Number(p.real_number_);
endtask

task Interp::visitStringLit(StringLit p);
  visitAnyChars(p.anychars_);
endtask

task Interp::visitListStmt_Item(ListStmt_Item  liststmt_item);
  Datum d;

  inc_scope();

  if ( exit_fatal )
    return;

  for (uint i = 0; i < liststmt_item.v.size(); i++) begin
`ifdef DEBUG
    $write("line: %0d\n", liststmt_item.v[i].line_number);
`endif
    liststmt_item.v[i].accept(this);
    if ( return_jump && in_call ) begin
`ifdef DEBUG
      $write("line: %0d, return_jump = %0d at line %0d\n", liststmt_item.v[i].line_number, return_jump, liststmt_item.v[i].line_number);
`endif
      d = pop();
      break;
    end
    if ( (break_jump || continue_jump) && in_loop ) begin
      break;
    end
    if ( exit_fatal )
      break;
  end

  if (scope == top_scope) begin
`ifdef DEBUG
     print_sym_table();
`endif
  end else
    dec_scope();

  if ( return_jump && in_call ) begin
    push(d);
  end
endtask

task Interp::visitListExpr(ListExpr  listexpr);
  for ( int i = 0; i < listexpr.v.size() ; i++)
  begin
    listexpr.v[i].accept(this);
  end
endtask

task Interp::visitListPrint_Arg(ListPrint_Arg  listprint_arg);
  prstr = "";
  for ( int i = 0; i < listprint_arg.v.size() ; i++)
  begin
    listprint_arg.v[i].accept(this);
  end
  $write(prstr);
endtask

task Interp::visitListFormal_Arg(ListFormal_Arg  listformal_arg);
  for ( int i = 0; i < listformal_arg.v.size() ; i++)
  begin
    listformal_arg.v[i].accept(this);
  end
endtask

task Interp::visitListElse_If(ListElse_If  listelse_if);
  Datum d;

  for ( int i = 0; i < listelse_if.v.size() ; i++)
  begin
    listelse_if.v[i].accept(this);

    d = top();
    if (d.ival) return;
  end
endtask


task Interp::visitDecimal_Number(Decimal_Number x);
  Datum d;

  d.ival = x.atoi();

  push(d);
endtask

task Interp::visitReal_Number(Real_Number x);
  Datum d;

  d.ival = x.atoreal();

  push(d);
endtask

task Interp::visitBinaryNumber(BinaryNumber x);
  Datum d;

  d.ival = x.atobin();

  push(d);
endtask

task Interp::visitHexNumber(HexNumber x);
  Datum d;

  d.ival = x.atohex();

  push(d);
endtask

task Interp::visitAnyChars(AnyChars x);
  Datum d;

  d.sval = x;

  push(d);
endtask

task Interp::visitInteger(Integer x);
  /* Code for Integer Goes Here */
endtask

task Interp::visitChar(Char x);
  /* Code for Char Goes Here */
endtask

task Interp::visitDouble(Double x);
  /* Code for Double Goes Here */
endtask

task Interp::visitString(String x);
  /* Code for String Goes Here */
endtask

task Interp::visitIdent(Ident x);
  Datum d;
  Symbol s = lookup(x);

  if ( s == null )
    s = install(x, UNDEF);
  d.sym = s;
  push(d);
endtask
