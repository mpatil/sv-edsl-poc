/* -*- sv -*- File generated by the BNF Converter (bnfc 2.9.6). */

/* Lexer definition for use with lex */

/* This lex file was machine-generated */
%{
`define YY_BUFFER_LENGTH 4096

string YY_PARSED_STRING;
task YY_BUFFER_APPEND(string s);
  s = {YY_PARSED_STRING, s}; //Do something better here!
endtask
task YY_BUFFER_RESET();
  for(int x = 0; x < `YY_BUFFER_LENGTH; x++)
    YY_PARSED_STRING[x] = 0;
endtask

%}

%{
int yy_mylinenumber = 0;
`define STRING_CAST(x)  string'(x)

%}


LETTER [a-zA-Z]
CAPITAL [A-Z]
SMALL [a-z]
DIGIT [0-9]
IDENT [a-zA-Z0-9'_]
%START YYINITIAL CHAR CHARESC CHAREND STRING ESCAPED COMMENT

%%  /* Rules. */

<YYINITIAL>";"      	 return `_SEMI;
<YYINITIAL>"{"      	 return `_LBRACE;
<YYINITIAL>"}"      	 return `_RBRACE;
<YYINITIAL>","      	 return `_COMMA;
<YYINITIAL>"="      	 return `_EQ;
<YYINITIAL>"("      	 return `_LPAREN;
<YYINITIAL>")"      	 return `_RPAREN;
<YYINITIAL>"**"      	 return `_DSTAR;
<YYINITIAL>"*"      	 return `_STAR;
<YYINITIAL>"/"      	 return `_SLASH;
<YYINITIAL>"%"      	 return `_PERCENT;
<YYINITIAL>"+"      	 return `_PLUS;
<YYINITIAL>"-"      	 return `_MINUS;
<YYINITIAL>"&"      	 return `_AMP;
<YYINITIAL>"^"      	 return `_CARET;
<YYINITIAL>"|"      	 return `_BAR;
<YYINITIAL>">>"      	 return `_DGT;
<YYINITIAL>"<<"      	 return `_DLT;
<YYINITIAL>"<"      	 return `_LT;
<YYINITIAL>"<="      	 return `_LDARROW;
<YYINITIAL>">"      	 return `_GT;
<YYINITIAL>">="      	 return `_GTEQ;
<YYINITIAL>"=="      	 return `_DEQ;
<YYINITIAL>"!="      	 return `_BANGEQ;
<YYINITIAL>"&&"      	 return `_DAMP;
<YYINITIAL>"||"      	 return `_DBAR;
<YYINITIAL>"?"      	 return `_QUESTION;
<YYINITIAL>":"      	 return `_COLON;
<YYINITIAL>"["      	 return `_LBRACK;
<YYINITIAL>"]"      	 return `_RBRACK;
<YYINITIAL>"!"      	 return `_BANG;
<YYINITIAL>"~"      	 return `_TILDE;
<YYINITIAL>"++"      	 return `_DPLUS;
<YYINITIAL>"--"      	 return `_DMINUS;
<YYINITIAL>"bin"      	 return `_KW_bin;
<YYINITIAL>"break"      	 return `_KW_break;
<YYINITIAL>"ceil"      	 return `_KW_ceil;
<YYINITIAL>"continue"      	 return `_KW_continue;
<YYINITIAL>"defined"      	 return `_KW_defined;
<YYINITIAL>"else"      	 return `_KW_else;
<YYINITIAL>"elsif"      	 return `_KW_elsif;
<YYINITIAL>"fatal"      	 return `_KW_fatal;
<YYINITIAL>"floor"      	 return `_KW_floor;
<YYINITIAL>"for"      	 return `_KW_for;
<YYINITIAL>"forever"      	 return `_KW_forever;
<YYINITIAL>"function"      	 return `_KW_function;
<YYINITIAL>"hex"      	 return `_KW_hex;
<YYINITIAL>"if"      	 return `_KW_if;
<YYINITIAL>"log2"      	 return `_KW_log2;
<YYINITIAL>"print"      	 return `_KW_print;
<YYINITIAL>"procedure"      	 return `_KW_procedure;
<YYINITIAL>"regrd"      	 return `_KW_regrd;
<YYINITIAL>"regwr"      	 return `_KW_regwr;
<YYINITIAL>"return"      	 return `_KW_return;
<YYINITIAL>"sys"      	 return `_KW_sys;
<YYINITIAL>"var"      	 return `_KW_var;
<YYINITIAL>"wait"      	 return `_KW_wait;
<YYINITIAL>"while"      	 return `_KW_while;

<YYINITIAL>"//"[^\n]*\n ++yy_mylinenumber;
<YYINITIAL>"/*" `BEGIN `COMMENT;
<COMMENT>"*/" `BEGIN `YYINITIAL;
<COMMENT>. /* skip */;
<COMMENT>[\n] ++yy_mylinenumber;

<YYINITIAL>{DIGIT}+    	 { yylval._string = `STRING_CAST(yytext); return `T_Decimal_Number; }
<YYINITIAL>{DIGIT}+\.{DIGIT}+    	 { yylval._string = `STRING_CAST(yytext); return `T_Real_Number; }
<YYINITIAL>0(B|b)(0|1)(0|1|\_)*    	 { yylval._string = `STRING_CAST(yytext); return `T_BinaryNumber; }
<YYINITIAL>0(X|x)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|\_|a|b|c|d|e|f)*    	 { yylval._string = `STRING_CAST(yytext); return `T_HexNumber; }
<YYINITIAL>\"[^\t\n\r\"]*\"    	 { yylval._string = `STRING_CAST(yytext); return `T_AnyChars; }
<YYINITIAL>{LETTER}{IDENT}*      	 { yylval._string = `STRING_CAST(yytext); return `_IDENT_; }
\n  ++yy_mylinenumber ;

<YYINITIAL>[ \t\r\n\f]      	 /* ignore white space. */;
<YYINITIAL>.      	 return `_ERROR_;

%%  /* Initialization code. */
task initialize_lexer(int inp); `BEGIN `YYINITIAL; endtask



